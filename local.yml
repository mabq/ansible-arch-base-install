- hosts: all
  tasks:


    # --- Security check ---
    #     Avoid applying this script by accident to any host

    - name: Security --- exit if not booted from arch install media
      when: ansible_nodename != 'archiso'
      ansible.builtin.fail:
        msg: "This host is not running the Archlinux Live Environment"


    # --- Set variables ---
    #     Get system information required later in the process

    - name: Check `efivars` directory existance
      ansible.builtin.stat:
        path: /sys/firmware/efi/efivars
      register: efivars
    - name: Get `firmware`
      ansible.builtin.set_fact:
        firmware: "{{ efivars.stat.exists | ternary('uefi', 'bios') }}"
    - name: Print `firmware`
      # https://wiki.archlinux.org/title/Arch_boot_process#Firmware_types
      ansible.builtin.debug:
        msg: "firmware = {{ firmware }}"

    - name: Get `device_name_descriptor`
      # get `sda` or `nvme0n1` from `/dev/sda` or `/dev/nvme0n1`
      # see: https://wiki.archlinux.org/title/Device_file#Block_devices
      ansible.builtin.set_fact:
        device_name_descriptor: "{{ installation_block_device_name | split('/') | last }}"
    - name: Print `device_name_descriptor`
      ansible.builtin.debug:
        msg: "device_name_descriptor = {{ device_name_descriptor }}"

    - name: Get `disk_discard_support`
      # I don't have a PC with an nvme drive to test this now. For nvme disks this should be false because nvme has built in support for TRIM. Check this again whenever you have the oportunity.
      ansible.builtin.set_fact:
        disk_discard_support: "{{ ansible_devices[device_name_descriptor]['support_discard'] != '0' }}"
    - name: Print `disk_discard_support`
      ansible.builtin.debug:
        msg: "disk_discard_support = {{ disk_discard_support }}"

    - name: Determine partition names based on firmware type
      ansible.builtin.set_fact:
        efi_partition_number: "{{ (firmware == 'uefi') | ternary('1', None) }}"
        boot_partition_number: "{{ (firmware == 'uefi') | ternary('2', '1') }}"
        main_partition_number: "{{ (firmware == 'uefi') | ternary('3', '2') }}"
    - name: Prepend with "p" for disks names that end with a number
      # See `https://wiki.archlinux.org/title/Device_file#Partition`
      when: device_name_descriptor | regex_search('[0-9]$')
      ansible.builtin.set_fact:
        efi_partition_number: "p{{ efi_partition_number }}"
        boot_partition_number: "p{{ boot_partition_number }}"
        main_partition_number: "p{{ main_partition_number }}"
    - name: Print partition names
      ansible.builtin.debug:
        msg: "efi_partition_number = {{ efi_partition_number }}, boot_partition_number = {{ boot_partition_number }}, main_partition_number = {{ main_partition_number }}"


    # --- Disk configuration ---

    - name: Wipe all disk partitions of the target disk
      ansible.builtin.command: find /dev -wholename "{{ installation_block_device_name }}*" -exec wipefs --force --all {} \;

    - name: Securely erase disk (if instructed)
      when: securely_erase_disk
      block:
      - name: Info
        ansible.builtin.debug:
          msg: "About to write random data to the entire disk, will take several hours to complete"
      - name: Write random data to disk
        ansible.builtin.command: dd if=/dev/urandom of={{ installation_block_device_name }}

    - name: UEFI - Disk partitions
      when: firmware == 'uefi'
      block:
      - name: UEFI - Create EFI partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: gpt
          number: "{{ efi_partition_number }}"
          part_end: 512MB
          name: EFI
          flags: [boot, esp]
          fs_type: fat32
          state: present
      - name: UEFI - Create boot partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: gpt
          number: "{{ boot_partition_number }}"
          part_start: 512MB
          part_end: 1536MB
          name: boot
          fs_type: ext4
          state: present
      - name: UEFI - Create main partition
        community.general.parted:
          device: '{{ installation_block_device_name }}'
          label: gpt
          number: "{{ main_partition_number }}"
          part_start: 1536MB
          name: root
          flags: [lvm]
          state: present

    - name: BIOS - Disk partitions
      when: firmware == 'bios'
      block:
      - name: BIOS - Create boot partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: msdos
          number: "{{ boot_partition_number }}"
          part_end: 1024MB
          #name: boot
          fs_type: ext4
          flags: [boot]
          state: present
      - name: BIOS - Create main partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: msdos
          number: "{{ main_partition_number }}"
          part_start: 1024MB
          #name: root
          flags: [lvm]
          state: present

    - name: Encrypt main partition
      community.crypto.luks_device:
        device: "{{ installation_block_device_name }}{{ main_partition_number }}"
        type: luks2
        new_passphrase: "{{ encryption_password }}"
        state: opened
        name: lvm
        passphrase: "{{ encryption_password }}"

    - name: LVM - Create volume group (physical volume is automatically created)
      community.general.lvg:
        pvs: /dev/mapper/lvm
        vg: main
        pvresize: true
        state: active

    - name: LVM - Create 'root' logical volume
      community.general.lvol:
        vg: main
        lv: root
        size: "{{ system_size_in_gb }}G"
        active: true
    - name: LVM - Create 'home' logical volume
      community.general.lvol:
        vg: main
        lv: home
        size: +100%FREE
        active: true

    - name: UEFI - Format EFI partition
      when: firmware == 'uefi'
      community.general.filesystem:
        dev: "{{ installation_block_device_name }}{{ efi_partition_number }}"
        fstype: vfat
        opts: '-F32'
    - name: Format boot partition
      community.general.filesystem:
        dev: "{{ installation_block_device_name }}{{ boot_partition_number }}"
        fstype: ext4
    - name: Format `root` logical volume
      community.general.filesystem:
        dev: /dev/main/root
        fstype: ext4
    - name: Format `home` logical volume
      community.general.filesystem:
        dev: /dev/main/home
        fstype: ext4

    - name: Create directory for '/home'
      ansible.builtin.file:
        path: /mnt/home
        state: directory
    - name: Create directory for '/boot'
      ansible.builtin.file:
        path: /mnt/boot
        state: directory

    - name: Mount the `root` logical volume to `/`
      ansible.posix.mount:
        src: /dev/main/root
        path: /mnt
        fstype: ext4
        state: mounted
    - name: Mount the `home` logical volumen to `/home`
      ansible.posix.mount:
        src: /dev/main/home
        path: /mnt/home
        fstype: ext4
        state: mounted
    - name: Mount the boot partition to `/mnt/boot`
      ansible.posix.mount:
        src: "{{ installation_block_device_name }}{{ boot_partition_number }}"
        path: /mnt/boot
        fstype: ext4
        state: mounted


    # --- Install packages ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== INSTALL PACKAGES =============================="

    - name: Install base packages
      ansible.builtin.command: pacstrap /mnt base linux linux-firmware grub lvm2 networkmanager

    - name: Install basic tools
      # `sudo` is required in case of disable-root-login
      # `git` is required to run `ansible-pull` on the second script
      ansible.builtin.command: pacstrap /mnt sudo neovim openssh ansible git

    - name: Install `efibootmgr` (UEFI only)
      when: firmware == 'uefi'
      ansible.builtin.command: pacstrap /mnt efibootmgr


    # --- System configuration ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== SYSTEM CONFIGURATION =============================="

    - name: fstab - create '/etc' directory
      ansible.builtin.file:
        path: /mnt/etc
        state: directory
    - name: fstab - generate file
      ansible.builtin.shell:
        cmd: genfstab -U -p /mnt >> /mnt/etc/fstab
    - name: fstab - enable TRIM support (if supported)
      when: disk_discard_support
      ansible.builtin.replace:
        path: /mnt/etc/fstab
        regexp: '(relatime)\s+'
        replace: '\1,discard\t'

    - name: Setup hostname
      ansible.builtin.copy:
        content: '{{ inventory_hostname }}'
        dest: /mnt/etc/hostname

    # - name: Setup timezone
    #   ansible.builtin.command: arch-chroot /mnt ln -sf /usr/share/zoneinfo/{{ timezone }} /etc/localtime
    # - name: Set hardware clock to current system time
    #   ansible.builtin.command: arch-chroot /mnt hwclock --systohc

    # - name: Locales - enable locales desired locales
    #   ansible.builtin.lineinfile:
    #     dest: /mnt/etc/locale.gen
    #     regexp: '#{{ item }}\.UTF-8 UTF-8'
    #     line: '{{ item }}.UTF-8 UTF-8'
    #   loop: '{{ locales }}'
    # - name: Locales - generate files
    #   ansible.builtin.command: arch-chroot /mnt locale-gen
    # - name: Locales - setup locale language
    #   ansible.builtin.copy:
    #     content: LANG={{ locales | first }}.UTF-8
    #     dest: /mnt/etc/locale.conf
    # - name: Locales - setup console keymap
    #   ansible.builtin.command: arch-chroot /mnt echo KEYMAP={{ console_keymap }} > /etc/vconsole.conf

    - name: Enable `NetworkManager` service
      # required to be able to connect to a wireless network later
      ansible.builtin.command: arch-chroot /mnt systemctl enable NetworkManager

    - name: Enable `sshd` service
      ansible.builtin.command: arch-chroot /mnt systemctl enable sshd


    # --- User account ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== USER ACCOUNT =============================="

    - name: User account - hash the password
      # Archlinux changed the password hashing algorithm from `sha512` to `yescript` (https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/). Openssl does not support `yescript` yet, when it does update the `-6` flag to the one corresponding to `yescript`. Whenever you change the password within the system using the `passwd` command, the new password will be automatically hashed with the new algorithm.
      ansible.builtin.command: openssl passwd -6 "{{ password }}"
      register: password_hash
    - name: User account - create account
      # cannot do with the user module because of the Live Environment, must be done manually
      # supplementary groups --- https://wiki.archlinux.org/title/Users_and_groups#Group_list
      ansible.builtin.command: "arch-chroot /mnt useradd {{ username }} --create-home --user-group --groups adm,wheel --password {{ password_hash.stdout }} "

    - name: User account - give passwordless sudo access
      # https://wiki.archlinux.org/title/Sudo#Configure_sudo_using_drop-in_files_in_/etc/sudoers.d
      ansible.builtin.copy:
        content: "{{ username }} ALL=(ALL:ALL) NOPASSWD: ALL"
        dest: /mnt/etc/sudoers.d/{{ username }}

    - name: User account - create vault_key file in user's home directory
      # This will allow us to run the second script without manually creating this file
      ansible.builtin.copy:
        content: "{{ encryption_password }}"
        dest: /mnt/home/{{ username }}/.vault_key
        # the module fails when trying to set the following, have to do it manually below
        # group: "{{ username }}"
        # owner: "{{ username }}"
        # mode: '0600'
    - name: Set mode, owner, and group on the vault_key file
      ansible.builtin.command: arch-chroot /mnt {{ item }}
      loop:
        - chmod 0600 /home/{{ username }}/.vault_key
        - chown {{ username }}:{{ username }} /home/{{ username }}/.vault_key


    # --- Root account ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== ROOT ACCOUNT =============================="
       
    - name: Enable root login
      when: not disable_root_login
      block:
      - name: root account - generate password hash
        # Archlinux changed the password hashing algorithm from `sha512` to `yescript` (https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/). Openssl does not support `yescript` yet, when it does update the `-6` flag to the one corresponding to `yescript`. Whenever you change the password within the system using the `passwd` command, the new password will be automatically hashed with the new algorithm.
        ansible.builtin.command: openssl passwd -6 "{{ encryption_password }}"
        register: encryption_password_hash
      - name: root account - manually add the hashed password to `/etc/shadow`
        # for the root user we must edit the shadow file manually, for some reason the `ansible.builtin.user` module won't work for root in the Live Environment
        ansible.builtin.replace:
          path: /mnt/etc/shadow
          regexp: (^root):([^:]*):(.*)
          replace: \1:{{ encryption_password_hash.stdout }}:\3

    - name: Disable root login
      when: disable_root_login
      # https://wiki.archlinux.org/title/Sudo#Disable_root_login
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/user_module.html#parameter-password
      # for the root user we must edit the shadow file manually, for some reason the `ansible.builtin.user` module won't work for root in the Live Environment
      ansible.builtin.replace:
        path: /mnt/etc/shadow
        regexp: (^root):([^:]*):(.*)
        replace: \1:!:\3


    # --- Initial ram filesystem ---
    #     The initramfs is a temporary filesystem that is loaded into memory during
    #     the boot process before the real root filesystem is mounted. We need to 
    #     recreate the initramfs with support for LVM and disk encryption.

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== INITRAMFS =============================="

    - name: initramfs - create a key file to avoid typing the encryption password twice during boot
      block:
      - name: initramfs - create an empty file
        ansible.builtin.shell: arch-chroot /mnt dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
      - name: initramfs - append the encryption key to it
        ansible.builtin.shell: echo "{{ encryption_password }}" | arch-chroot /mnt  cryptsetup luksAddKey {{ installation_block_device_name }}{{ main_partition_number }} /crypto_keyfile.bin -
      - name: initramfs - remove all permissions for security reasons
        ansible.builtin.command: arch-chroot /mnt chmod 000 /crypto_keyfile.bin

    - name: initramfs - change configuration options for the `mkinitcpio` script
      # mkinitcpio is a Bash script used to create an initial ramdisk environment
      ansible.builtin.lineinfile:
        dest: /mnt/etc/mkinitcpio.conf
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # add the key file
        - { regex: ^FILES, line: FILES=(/crypto_keyfile.bin) }
        # add teh `encrypt` and `lvm2` hooks
        - { regex: ^HOOKS, line: HOOKS=(base udev autodetect modconf kms keyboard keymap consolefont block encrypt lvm2 filesystems fsck) }

    - name: initramfs - Generate the initial ramdisk image for `linux`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -P


    # --- Bootloader ---
    #     https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== BOOTLOADER =============================="

    - name: Bootloader (UEFI) - Create '/boot/EFI' directory
      when: firmware == 'uefi'
      ansible.builtin.file:
        path: /mnt/boot/EFI
        state: directory
    - name: Bootloader (UEFI) - Mount EFI partition
      when: firmware == 'uefi'
      ansible.posix.mount:
        src: "{{ installation_block_device_name }}{{ efi_partition_number }}"
        path: /mnt/boot/EFI
        fstype: vfat
        state: mounted

    - name: Bootloader (BIOS) - Install GRUB in the master boot record
      when: firmware == 'bios'
      # pass a disk as an argument, not a partition
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=i386-pc --recheck {{ installation_block_device_name }}"
    - name: Bootloader (UEFI) - Install GRUB in the master boot record
      when: firmware == 'uefi'
      # pass a disk as an argument, not a partition
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=x86_64-efi"

    - name: Bootloader - Configure GRUB to unlock the encrypted partiton at boot time and to allow-discards (if supported)
      ansible.builtin.lineinfile:
        dest: /mnt/etc/default/grub
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # enable encryption
        - { regex: ^#GRUB_ENABLE_CRYPTODISK, line: GRUB_ENABLE_CRYPTODISK=y }
        # enable TRIM (if supported) and encryption
        - { regex: ^GRUB_CMDLINE_LINUX="", line: "GRUB_CMDLINE_LINUX=\"{{ disk_discard_support | ternary('cryptdevice={{ installation_block_device_name }}{{ main_partition_number }}:lvm:allow-discards', 'cryptdevice={{ installation_block_device_name }}{{ main_partition_number }}:lvm') }}\"" }

    - name: Bootloader - Generate the GRUB configuration file
      ansible.builtin.command: "arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg"


    # --- Enable SWAP ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== ENABLE SWAP =============================="

    - name: Enable SWAP
      when: swap_size_in_mb > 0
      block:
      - name: SWAP - Create empty file of desired size
        ansible.builtin.command: arch-chroot /mnt dd if=/dev/zero of=/swapfile bs=1M count={{ swap_size_in_mb }} status=progress
      - name: SWAP - Change file permissions
        ansible.builtin.command: arch-chroot /mnt chmod 600 /swapfile
      - name: SWAP - Set file as swap file
        ansible.builtin.command: arch-chroot /mnt mkswap /swapfile
      - name: SWAP - Include swap file in `/etc/fstab`
        ansible.builtin.lineinfile:
          path: /mnt/etc/fstab
          line: "/swapfile none swap sw 0 0"
      - name: SWAP - Check fstab file correctness
        ansible.builtin.command: arch-chroot /mnt mount -a
      - name: SWAP - Enable
        ansible.builtin.command: arch-chroot /mnt swapon -a


    # --- Reboot and exit playbook

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== RESTARTING =============================="
      
    - name: Shutdown
      community.general.shutdown:

    - name: Exit playbook gracefully
      ansible.builtin.meta: end_host


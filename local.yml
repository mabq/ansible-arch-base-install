- hosts: all
  tasks:

    # --- Check live environment

    - name: Stop if not booted from arch install media
      when: ansible_nodename != 'archiso'
      ansible.builtin.fail:
        msg: "This host is not booted from the Arch install media!"

    # --- Set variables

    - name: Check `efivars` directory existance
      ansible.builtin.stat:
        path: /sys/firmware/efi/efivars
      register: efivars
    - name: Set `firmware`
      ansible.builtin.set_fact:
        firmware: "{{ efivars.stat.exists | ternary('uefi', 'bios') }}"
    - name: Print `firmware`
      # https://wiki.archlinux.org/title/Arch_boot_process#Firmware_types
      ansible.builtin.debug:
        msg: "firmware = {{ firmware }}"

    - name: Set 'disk_name'
      # get `sda` or `nvme0n1` from `/dev/sda` or `/dev/nvme0n1`
      # see: https://wiki.archlinux.org/title/Device_file#Block_devices
      ansible.builtin.set_fact:
        disk_name: "{{ target_disk | split('/') | last }}"
    - name: Print 'disk_name'
      ansible.builtin.debug:
        msg: "disk_name = {{ disk_name }}"

    - name: Set 'disk_discard_support'
      # I don't have a PC with an nvme drive to test this now. For nvme disks this should be false because nvme has built in support for TRIM. Check this again whenever you have the oportunity.
      ansible.builtin.set_fact:
        disk_discard_support: "{{ ansible_devices[disk_name]['support_discard'] != '0' }}"
    - name: Print 'disk_discard_support'
      ansible.builtin.debug:
        msg: "disk_discard_support = {{ disk_discard_support }}"

    - name: Assign numbers to partition variables depending on firmware
      ansible.builtin.set_fact:
        efi_partition_number: "{{ (firmware == 'uefi') | ternary('1', None) }}"
        boot_partition_number: "{{ (firmware == 'uefi') | ternary('2', '1') }}"
        root_partition_number: "{{ (firmware == 'uefi') | ternary('3', '2') }}"
    - name: Add the "p" prefix to partition names (for disk names that end with a number)
      # See `https://wiki.archlinux.org/title/Device_file#Partition`
      when: disk_name | regex_search('[0-9]$')
      ansible.builtin.set_fact:
        efi_partition_number: "p{{ efi_partition_number }}"
        boot_partition_number: "p{{ boot_partition_number }}"
        root_partition_number: "p{{ root_partition_number }}"
    - name: Print partition names
      ansible.builtin.debug:
        msg: "efi_partition_number = {{ efi_partition_number }}, boot_partition_number = {{ boot_partition_number }}, root_partition_number = {{ root_partition_number }}"

    # --- Prepare disk

    - name: Wipe disk partitions
      ansible.builtin.command: find /dev -wholename "{{ target_disk }}*" -exec wipefs --force --all {} \;

    - name: Securely erase disk (if instructed)
      when: secure_erase_disk
      block:
      - name: Info
        ansible.builtin.debug:
          msg: "About to write random data to the entire disk, will take several hours to complete."
      - name: Write random data to disk
        ansible.builtin.command: dd if=/dev/urandom of={{ target_disk }}

    - name: UEFI - Disk partitions
      when: firmware == 'uefi'
      block:
      - name: UEFI - Create EFI partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: gpt
          number: "{{ efi_partition_number }}"
          part_end: 512MB
          name: EFI
          flags: [boot, esp]
          fs_type: fat32
          state: present
      - name: UEFI - Create boot partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: gpt
          number: "{{ boot_partition_number }}"
          part_start: 512MB
          part_end: 1536MB
          name: boot
          fs_type: ext4
          state: present
      - name: UEFI - Create root partition
        community.general.parted:
          device: '{{ target_disk }}'
          label: gpt
          number: "{{ root_partition_number }}"
          part_start: 1536MB
          name: root
          flags: [lvm]
          state: present

    - name: BIOS - Disk partitions
      when: firmware == 'bios'
      block:
      - name: BIOS - Create boot partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: msdos
          number: "{{ boot_partition_number }}"
          part_end: 1024MB
          #name: boot
          fs_type: ext4
          flags: [boot]
          state: present
      - name: BIOS - Create root partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: msdos
          number: "{{ root_partition_number }}"
          part_start: 1024MB
          #name: root
          flags: [lvm]
          state: present

    - name: Encrypt root partition
      community.crypto.luks_device:
        device: "{{ target_disk }}{{ root_partition_number }}"
        type: luks2
        new_passphrase: "{{ password }}"
        state: opened
        name: crypt
        passphrase: "{{ password }}"

    - name: LVM - Create volume group (physical volume is automatically created)
      community.general.lvg:
        pvs: /dev/mapper/crypt
        vg: vg0
        pvresize: true
        state: active

    - name: LVM - Create 'root' logical volume
      community.general.lvol:
        vg: vg0
        lv: root
        size: "{{ root_size_in_gb }}"
        active: true
    - name: LVM - Create 'home' logical volume
      community.general.lvol:
        vg: vg0
        lv: home
        size: +100%FREE
        active: true

    - name: UEFI - Format EFI partition
      when: firmware == 'uefi'
      community.general.filesystem:
        dev: "{{ target_disk }}{{ efi_partition_number }}"
        fstype: vfat
        opts: '-F32'
    - name: Format boot partition
      community.general.filesystem:
        dev: "{{ target_disk }}{{ boot_partition_number }}"
        fstype: ext4
    - name: Format `root` logical volume
      community.general.filesystem:
        dev: /dev/vg0/root
        fstype: ext4
    - name: Format `home` logical volume
      community.general.filesystem:
        dev: /dev/vg0/home
        fstype: ext4

    - name: Create directory for '/home'
      ansible.builtin.file:
        path: /mnt/home
        state: directory
    - name: Create directory for '/boot'
      ansible.builtin.file:
        path: /mnt/boot
        state: directory

    - name: Mount root
      ansible.posix.mount:
        src: /dev/vg0/root
        path: /mnt
        fstype: ext4
        state: mounted
    - name: Mount home
      ansible.posix.mount:
        src: /dev/vg0/home
        path: /mnt/home
        fstype: ext4
        state: mounted
    - name: Mount boot
      ansible.posix.mount:
        src: "{{ target_disk }}{{ boot_partition_number }}"
        path: /mnt/boot
        fstype: ext4
        state: mounted

    # --- Installation

    - name: Install system packages
      ansible.builtin.command: pacstrap /mnt base linux linux-lts linux-firmware grub lvm2 neovim networkmanager openssh ansible

    - name: UEFI - Install `efibootmgr`
      when: firmware == 'uefi'
      ansible.builtin.command: pacstrap /mnt efibootmgr

    # --- Configure the system

    - name: fstab - Create '/etc' directory
      ansible.builtin.file:
        path: /mnt/etc
        state: directory
    - name: fstab - Generate file
      ansible.builtin.shell:
        cmd: genfstab -U -p /mnt >> /mnt/etc/fstab
    - name: fstab - Enable TRIM support (if supported)
      when: disk_discard_support
      ansible.builtin.replace:
        path: /mnt/etc/fstab
        regexp: '(relatime)\s+'
        replace: '\1,discard\t'

    # - name: root - generate password hash
    #   ansible.builtin.command: openssl passwd -6 "{{ password }}"
    #   register: passwd_hash
    # - name: root - manually edit `/etc/shadow` to change password
    #   # apparently for security reasons neither `ansible.builtin.user` or `ansible.builtin.shell` modules will let you change the root password. Doing it manually by editing `/etc/shadow`.
    #   ansible.builtin.replace:
    #     path: /mnt/etc/shadow
    #     regexp: (^root):([^:]*):(.*)
    #     replace: \1:{{ passwd_hash.stdout }}:\3

    - name: Change root password
      ansible.builtin.user:
        name: root
        password: "{{ password | password_hash('sha512') }}"

    - name: Enable sshd and NetworkManager
      ansible.builtin.command: arch-chroot /mnt systemctl enable sshd NetworkManager

    - name: Set time zone
      ansible.builtin.command: arch-chroot /mnt ln -sf /usr/share/zoneinfo/{{ timezone }} /etc/localtime
    - name: set hardware clock to current system time
      ansible.builtin.command: arch-chroot /mnt hwclock --systohc

    - name: Enable locales
      lineinfile:
        dest: /mnt/etc/locale.gen
        regexp: '#{{ item }}\.UTF-8 UTF-8'
        line: '{{ item }}.UTF-8 UTF-8'
      loop: '{{ locales }}'
    - name: Generate locales
      ansible.builtin.command: arch-chroot /mnt locale-gen
    - name: Set default locale
      ansible.builtin.copy:
        content: LANG={{ locales | first }}.UTF-8
        dest: /mnt/etc/locale.conf
    - name: Setup console keymap
      ansible.builtin.command: arch-chroot /mnt echo KEYMAP={{ console_keymap }} > /etc/vconsole.conf

    - name: Setup hostname
      ansible.builtin.copy:
        content: '{{ inventory_hostname }}'
        dest: /mnt/etc/hostname

    # --- Initial ram filesystem configuration

    - name: initramfs - Create file to store key
      ansible.builtin.shell: arch-chroot /mnt dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
    - name: initramfs - Populate file with key content
      ansible.builtin.shell: echo "{{ password }}" | arch-chroot /mnt  cryptsetup luksAddKey {{ target_disk }}{{ root_partition_number }} /crypto_keyfile.bin -
    - name: initramfs - Remove all permissions from key file
      ansible.builtin.command: arch-chroot /mnt chmod 000 /crypto_keyfile.bin
    - name: initramfs - Enable keyfile, encryption and lvm
      lineinfile:
        dest: /mnt/etc/mkinitcpio.conf
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        - { regex: ^FILES, line: FILES=(/crypto_keyfile.bin) }
        - { regex: ^HOOKS, line: HOOKS=(base udev autodetect modconf kms keyboard keymap consolefont numlock block encrypt lvm2 filesystems fsck) }
    - name: initramfs - Generate the initial ramdisk image for `linux`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -p linux
    - name: initramfs - Generate the initial ramdisk image for `linux-lts`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -p linux-lts

    # --- Bootloader configuration
    #     (https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader)

    - name: UEFI - Create '/boot/EFI' directory
      when: firmware == 'uefi'
      ansible.builtin.file:
        path: /mnt/boot/EFI
        state: directory
    - name: UEFI - Mount EFI partition
      when: firmware == 'uefi'
      ansible.posix.mount:
        src: "{{ target_disk }}{{ efi_partition_number }}"
        path: /mnt/boot/EFI
        fstype: vfat
        state: mounted

    - name: UEFI - Install grub
      when: firmware == 'uefi'
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=x86_64-efi --recheck {{ target_disk }}"
    - name: BIOS - Install grub
      when: firmware == 'bios'
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=i386-pc --recheck {{ target_disk }}"

    - name: GRUB configuration - Enable encryption and TRIM (if supported)
      lineinfile:
        dest: /mnt/etc/default/grub
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # enable encryption
        - { regex: ^#GRUB_ENABLE_CRYPTODISK, line: GRUB_ENABLE_CRYPTODISK=y }
        # enable TRIM (if supported) and encryption
        - { regex: ^GRUB_CMDLINE_LINUX="", line: "GRUB_CMDLINE_LINUX=\"{{ disk_discard_support | ternary('cryptdevice={{ target_disk }}{{ root_partition_number }}:crypt:allow-discards', 'cryptdevice={{ target_disk }}{{ root_partition_number }}:crypt') }}\"" }
    - name: GRUB - Generate boot loader file
      ansible.builtin.command: "arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg"

    # --- Swap configuration

    - name: Configure swap
      when: swap_size_in_mb > 0
      block:
      - name: Swap - Create empty file of desired size
        ansible.builtin.command: arch-chroot /mnt dd if=/dev/zero of=/swapfile bs=1M count={{ swap_size_in_mb }} status=progress
      - name: Swap - Change file permissions
        ansible.builtin.command: arch-chroot /mnt chmod 600 /swapfile
      - name: Swap - Set file as swap file
        ansible.builtin.command: arch-chroot /mnt mkswap /swapfile
      - name: Swap - Include swap file in `/etc/fstab`
        lineinfile:
          path: /mnt/etc/fstab
          line: "/swapfile none swap sw 0 0"
      - name: Swap - Check fstab file correctness
        ansible.builtin.command: arch-chroot /mnt mount -a
      - name: Swap - Enable
        ansible.builtin.command: arch-chroot /mnt swapon -a

    # --- Reboot and exit playbook
      
    - name: Shutdown
      community.general.shutdown:

    - name: Exit playbook gracefully
      ansible.builtin.meta: end_host


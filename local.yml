- hosts: all
  tasks:


    # --- Security check -------------------------------------------------------

    # Avoid applying this script by accident to any host

    - name: Exit playbook if system was not booted from arch install media
      when: ansible_nodename != 'archiso'
      ansible.builtin.fail:
        msg: "This host is not running the Archlinux Live Environment"



    # --- Get system info ------------------------------------------------------

    # Store some important information about the system into variables that 
    # we will use later on.

    - name: Get firmware type
      # Disk partition will depend on firmware type.
      # See https://wiki.archlinux.org/title/Arch_boot_process#Firmware_types
      block:
      - name: Check `efivars` directory existance
        ansible.builtin.stat:
          path: /sys/firmware/efi/efivars
        register: efivars
      - name: Get `firmware` type
        ansible.builtin.set_fact:
          firmware: "{{ efivars.stat.exists | ternary('uefi', 'bios') }}"
      - name: Print info
        ansible.builtin.debug:
          msg: "firmware = {{ firmware }}"

    - name: Get `device_name_descriptor`
      # For some actions below we need just the `sda` or `nvme0n1` part from 
      # `/dev/sda` or `/dev/nvme0n1`
      # See https://wiki.archlinux.org/title/Device_file#Block_devices
      ansible.builtin.set_fact:
        device_name_descriptor: "{{ installation_block_device_name | split('/') | last }}"
    - name: Print info
      ansible.builtin.debug:
        msg: "device_name_descriptor = {{ device_name_descriptor }}"

    - name: Get `disk_discard_support`
      # If the disk has discard support we will enable ir later on.
      # I don't have a PC with an nvme drive to test this now. For nvme disks 
      # this should be false because nvme has built in support for TRIM. 
      # Check this again whenever you have the oportunity.
      ansible.builtin.set_fact:
        disk_discard_support: "{{ ansible_devices[device_name_descriptor]['support_discard'] != '0' }}"
    - name: Print info
      ansible.builtin.debug:
        msg: "disk_discard_support = {{ disk_discard_support }}"

    - name: Determine partition names based on firmware type
      ansible.builtin.set_fact:
        efi_partition_number: "{{ (firmware == 'uefi') | ternary('1', None) }}"
        boot_partition_number: "{{ (firmware == 'uefi') | ternary('2', '1') }}"
        main_partition_number: "{{ (firmware == 'uefi') | ternary('3', '2') }}"
    - name: Prepend with "p" for disks names that end with a number
      # See `https://wiki.archlinux.org/title/Device_file#Partition`
      when: device_name_descriptor | regex_search('[0-9]$')
      ansible.builtin.set_fact:
        efi_partition_number: "p{{ efi_partition_number }}"
        boot_partition_number: "p{{ boot_partition_number }}"
        main_partition_number: "p{{ main_partition_number }}"
    - name: Print info
      ansible.builtin.debug:
        msg: "efi_partition_number = {{ efi_partition_number }}, boot_partition_number = {{ boot_partition_number }}, main_partition_number = {{ main_partition_number }}"



    # --- Disk configuration ---------------------------------------------------

    - name: Wipe all disk partitions of the target disk
      ansible.builtin.command: find /dev -wholename "{{ installation_block_device_name }}*" -exec wipefs --force --all {} \;

    - name: Securely erase disk (if enabled, not by default)
      when: securely_erase_disk
      block:
      - name: Warn about overwritting disk content time
        ansible.builtin.debug:
          msg: "About to write random data to the entire disk, this will take several hours to complete"
      - name: Write random data to disk
        ansible.builtin.command: dd if=/dev/urandom of={{ installation_block_device_name }}

    - name: Create disk partition for UEFI systems
      when: firmware == 'uefi'
      block:
      - name: UEFI - Create EFI partition
        # To boot from a disk using UEFI, an EFI system partition is required.
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: gpt
          number: "{{ efi_partition_number }}"
          #part_start: (disk start)
          part_end: 512MB
          name: EFI
          flags: [boot, esp]
          fs_type: fat32
          state: present
      - name: UEFI - Create boot partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: gpt
          number: "{{ boot_partition_number }}"
          part_start: 512MB
          part_end: 1536MB
          name: boot
          fs_type: ext4
          state: present
      - name: UEFI - Create main partition
        community.general.parted:
          device: '{{ installation_block_device_name }}'
          label: gpt
          number: "{{ main_partition_number }}"
          part_start: 1536MB
          #part_end: (disk end)
          name: main
          flags: [lvm]
          state: present

    - name: BIOS - Disk partitions
      when: firmware == 'bios'
      block:
      - name: BIOS - Create boot partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: msdos
          number: "{{ boot_partition_number }}"
          #part_start: (disk start)
          part_end: 1024MB
          #name: (no support for name)
          fs_type: ext4
          flags: [boot]
          state: present
      - name: BIOS - Create main partition
        community.general.parted:
          device: "{{ installation_block_device_name }}"
          label: msdos
          number: "{{ main_partition_number }}"
          part_start: 1024MB
          #part_end: (disk end)
          #name: (no support for name)
          flags: [lvm]
          state: present

    - name: Encrypt main partition (where system and user files will be stored)
      # Data encryption at rest - the disk won't be readable unless you enter
      # the encryption password.
      community.crypto.luks_device:
        device: "{{ installation_block_device_name }}{{ main_partition_number }}"
        type: luks2
        new_passphrase: "{{ encryption_password }}"
        state: opened
        name: crypt
        passphrase: "{{ encryption_password }}"

    - name: LVM setup
      # Logical Volume Manager (LVM) is a storage management solution that 
      # provides a more flexible way to manage disk space compared to 
      # traditional partitioning. 
      block:
      - name: LVM - Create volume group (physical volume is automatically created)
        community.general.lvg:
          pvs: /dev/mapper/crypt
          vg: lvm
          pvresize: true
          state: active
      - name: LVM - Create 'root' logical volume
        community.general.lvol:
          vg: lvm
          lv: root
          size: "{{ system_size_in_gb }}G"
          active: true
      - name: LVM - Create 'home' logical volume
        community.general.lvol:
          vg: lvm
          lv: home
          # use all remaining space for user files
          size: +100%FREE
          active: true

    - name: Format EFI partition (UEFI only)
      when: firmware == 'uefi'
      community.general.filesystem:
        dev: "{{ installation_block_device_name }}{{ efi_partition_number }}"
        fstype: vfat
        opts: '-F32'
    - name: Format boot partition
      community.general.filesystem:
        dev: "{{ installation_block_device_name }}{{ boot_partition_number }}"
        fstype: ext4
    - name: Format `root` LVM logical volume
      community.general.filesystem:
        dev: /dev/lvm/root
        fstype: ext4
    - name: Format `home` LVM logical volume
      community.general.filesystem:
        dev: /dev/lvm/home
        fstype: ext4

    # `/mnt` is the linux directory where you are suppoused to mount external 
    # disks. The live environment is running completely from memory, then we 
    # will mount our logical volumes to those directories.
    - name: Create directory for '/home'
      ansible.builtin.file:
        path: /mnt/home
        state: directory
    - name: Create directory for '/boot'
      ansible.builtin.file:
        path: /mnt/boot
        state: directory

    - name: Mount the `root` logical volume to `/mnt`
      # must go first
      ansible.posix.mount:
        src: /dev/lvm/root
        path: /mnt
        fstype: ext4
        state: mounted
    - name: Mount the `home` logical volumen to `/mnt/home`
      ansible.posix.mount:
        src: /dev/lvm/home
        path: /mnt/home
        fstype: ext4
        state: mounted
    - name: Mount the boot partition to `/mnt/boot`
      ansible.posix.mount:
        src: "{{ installation_block_device_name }}{{ boot_partition_number }}"
        path: /mnt/boot
        fstype: ext4
        state: mounted



    # --- Install packages -----------------------------------------------------

    - name: Install base packages
      ansible.builtin.command: pacstrap /mnt base linux linux-firmware grub lvm2 networkmanager

    - name: Install basic tools
      # `sudo` is required in case of disable-root-login
      # `git` is required to run `ansible-pull` on the second script
      ansible.builtin.command: pacstrap /mnt sudo neovim openssh ansible git

    - name: Install `efibootmgr` (UEFI only)
      # used by the GRUB installation script to write boot entries to NVRAM
      when: firmware == 'uefi'
      ansible.builtin.command: pacstrap /mnt efibootmgr



    # --- System configuration -------------------------------------------------

    - name: fstab
      # The fstab file contains information about the partitions that should be 
      # automatically mounted on system boot.
      # All currently mounted partitions will be included - that is why we have 
      # not mount the EFI partition yet.
      block:
      - name: fstab - create '/etc' directory
        ansible.builtin.file:
          path: /mnt/etc
          state: directory
      - name: fstab - generate file
        ansible.builtin.shell:
          cmd: genfstab -U -p /mnt >> /mnt/etc/fstab
      - name: fstab - enable TRIM support (if supported)
        when: disk_discard_support
        ansible.builtin.replace:
          path: /mnt/etc/fstab
          regexp: '(relatime)\s+'
          replace: '\1,discard\t'

    - name: Setup hostname
      ansible.builtin.copy:
        content: '{{ inventory_hostname }}'
        dest: /mnt/etc/hostname

    # - name: Setup timezone (to be done by the `arch-setup` playbook)
    #   ansible.builtin.command: arch-chroot /mnt ln -sf /usr/share/zoneinfo/{{ timezone }} /etc/localtime
    # - name: Set hardware clock to current system time
    #   ansible.builtin.command: arch-chroot /mnt hwclock --systohc

    # - name: Locales - enable desired locales (to be done by the `arch-setup` playbook)
    #   ansible.builtin.lineinfile:
    #     dest: /mnt/etc/locale.gen
    #     regexp: '#{{ item }}\.UTF-8 UTF-8'
    #     line: '{{ item }}.UTF-8 UTF-8'
    #   loop: '{{ locales }}'
    # - name: Locales - generate files
    #   ansible.builtin.command: arch-chroot /mnt locale-gen
    # - name: Locales - setup locale language
    #   ansible.builtin.copy:
    #     content: LANG={{ locales | first }}.UTF-8
    #     dest: /mnt/etc/locale.conf
    # - name: Locales - setup console keymap
    #   ansible.builtin.command: arch-chroot /mnt echo KEYMAP={{ console_keymap }} > /etc/vconsole.conf

    - name: Enable `NetworkManager` service
      # Required to be able to connect to a wireless network after installation
      ansible.builtin.command: arch-chroot /mnt systemctl enable NetworkManager

    - name: Enable `sshd` service
      ansible.builtin.command: arch-chroot /mnt systemctl enable sshd



    # --- User account ---

    - name: Hash the password for the user account
      # Archlinux changed the password hashing algorithm from `sha512` to 
      # `yescript` (see https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/).
      # Openssl does not support `yescript` yet, when it does update the `-6` 
      # flag to the one corresponding to `yescript`. Whenever you change the 
      # password within the system using the `passwd` command, the new password 
      # will be automatically hashed with the new algorithm.
      ansible.builtin.command: openssl passwd -6 "{{ password }}"
      register: password_hash

    - name: Create user account
      # Use the `command` module, the `user` module would create the user on 
      # the live environment, not in the targeted installation.
      # For supplementary groups info see https://wiki.archlinux.org/title/Users_and_groups#Group_list
      ansible.builtin.command: "arch-chroot /mnt useradd {{ username }} --create-home --user-group --groups adm,wheel --password {{ password_hash.stdout }}"
      ignore_errors: true

    - name: Give the user account passwordless sudo access
      # https://wiki.archlinux.org/title/Sudo#Configure_sudo_using_drop-in_files_in_/etc/sudoers.d
      ansible.builtin.copy:
        content: "{{ username }} ALL=(ALL:ALL) NOPASSWD: ALL"
        dest: /mnt/etc/sudoers.d/{{ username }}

    - name: Create vault_key file in the user's home directory
      # This will allow us to run the second script without manually creating 
      # this file, we already have the encryption password available here.
      ansible.builtin.copy:
        content: "{{ encryption_password }}"
        dest: /mnt/home/{{ username }}/.vault_key
        # the module fails when trying to set the following (have to do it 
        # manually on next task):
        # group: "{{ username }}"
        # owner: "{{ username }}"
        # mode: '0600'
    - name: Set group, owner and mode on the vault_key file
      ansible.builtin.command: arch-chroot /mnt {{ item }}
      loop:
        - chown {{ username }}:{{ username }} /home/{{ username }}/.vault_key
        - chmod 0600 /home/{{ username }}/.vault_key



    # --- Root account ---

    - name: Enable root login
      when: not disable_root_login
      block:
      - name: root account - generate password hash
        # Archlinux changed the password hashing algorithm from `sha512` to
        # `yescript` (see https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/).
        # Openssl does not support `yescript` yet, when it does update the
        # `-6` flag to the one corresponding to `yescript`. Whenever you
        # change the password within the system using the `passwd` command,
        # the new password will be automatically hashed with the new algorithm.
        ansible.builtin.command: openssl passwd -6 "{{ encryption_password }}"
        register: encryption_password_hash
      - name: root account - manually add the hashed password to `/etc/shadow`
        # Do it manually, the `user` module would affect the root user of the 
        # live environment.
        ansible.builtin.replace:
          path: /mnt/etc/shadow
          regexp: (^root):([^:]*):(.*)
          replace: \1:{{ encryption_password_hash.stdout }}:\3

    - name: Disable root login
      when: disable_root_login
      # https://wiki.archlinux.org/title/Sudo#Disable_root_login
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/user_module.html#parameter-password
      # Do it manually, the `user` module would affect the root user of the 
      # live environment.
      ansible.builtin.replace:
        path: /mnt/etc/shadow
        regexp: (^root):([^:]*):(.*)
        replace: \1:!:\3



    # --- Initial ram filesystem ---
    
    #     The initramfs is a temporary filesystem that is loaded into memory
    #     during the boot process before the real root filesystem is mounted.
    #     We need to recreate the initramfs with support for LVM and disk
    #     encryption.

    - name: Create a key file to avoid typing the encryption password twice during boot
      block:
      - name: initramfs - create an empty file
        ansible.builtin.shell: arch-chroot /mnt dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
      - name: initramfs - append the encryption key to it
        ansible.builtin.shell: echo "{{ encryption_password }}" | arch-chroot /mnt  cryptsetup luksAddKey {{ installation_block_device_name }}{{ main_partition_number }} /crypto_keyfile.bin -
      - name: initramfs - remove all permissions for security reasons
        ansible.builtin.command: arch-chroot /mnt chmod 000 /crypto_keyfile.bin

    - name: Change configuration options for the `mkinitcpio` script
      # mkinitcpio is a Bash script used to create an initial ramdisk environment
      ansible.builtin.lineinfile:
        dest: /mnt/etc/mkinitcpio.conf
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # Add the key file
        - { regex: ^FILES, line: FILES=(/crypto_keyfile.bin) }
        # Add the `encrypt` and `lvm2` hooks
        - { regex: ^HOOKS, line: HOOKS=(base udev autodetect modconf kms keyboard keymap consolefont block encrypt lvm2 filesystems fsck) }

    - name: Generate the initial ramdisk image for `linux`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -P



    # --- Bootloader ---

    #     https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader

    - name: Create '/boot/EFI' directory (UEFI only)
      when: firmware == 'uefi'
      ansible.builtin.file:
        path: /mnt/boot/EFI
        state: directory
    - name: Mount the EFI partition (UEFI only)
      when: firmware == 'uefi'
      ansible.posix.mount:
        src: "{{ installation_block_device_name }}{{ efi_partition_number }}"
        path: /mnt/boot/EFI
        fstype: vfat
        state: mounted

    - name: Install GRUB (BIOS)
      when: firmware == 'bios'
      # pass a disk as an argument, not a partition
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=i386-pc {{ installation_block_device_name }}"
    - name: Install GRUB (UEFI)
      when: firmware == 'uefi'
      # https://wiki.archlinux.org/title/GRUB#Installation
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=GRUB"

    - name: Configure GRUB to unlock the encrypted partiton at boot time and to allow-discards (if supported)
      # https://wiki.archlinux.org/title/GRUB#Configuration
      ansible.builtin.lineinfile:
        dest: /mnt/etc/default/grub
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # Enable encryption
        - { regex: ^#GRUB_ENABLE_CRYPTODISK, line: GRUB_ENABLE_CRYPTODISK=y }
        # Enable TRIM (if supported) and encryption
        - { regex: ^GRUB_CMDLINE_LINUX="", line: "GRUB_CMDLINE_LINUX=\"{{ disk_discard_support | ternary('cryptdevice={{ installation_block_device_name }}{{ main_partition_number }}:crypt:allow-discards', 'cryptdevice={{ installation_block_device_name }}{{ main_partition_number }}:crypt') }}\"" }

    - name: Generate the GRUB configuration file
      ansible.builtin.command: "arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg"



    # --- Enable SWAP ---

    - name: Enable SWAP
      when: swap_size_in_mb > 0
      block:
      - name: SWAP - Create empty file of desired size
        ansible.builtin.command: arch-chroot /mnt dd if=/dev/zero of=/swapfile bs=1M count={{ swap_size_in_mb }} status=progress
      - name: SWAP - Change file permissions
        ansible.builtin.command: arch-chroot /mnt chmod 600 /swapfile
      - name: SWAP - Set file as swap file
        ansible.builtin.command: arch-chroot /mnt mkswap /swapfile
      - name: SWAP - Include swap file in `/etc/fstab`
        ansible.builtin.lineinfile:
          path: /mnt/etc/fstab
          line: "/swapfile none swap sw 0 0"
      - name: SWAP - Check fstab file correctness
        ansible.builtin.command: arch-chroot /mnt mount -a
      - name: SWAP - Enable
        ansible.builtin.command: arch-chroot /mnt swapon -a



    # --- Reboot and exit playbook ---

    - name: Shutdown
      community.general.shutdown:

    - name: Exit playbook gracefully
      ansible.builtin.meta: end_host


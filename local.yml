- hosts: all
  tasks:


    # --- Security check ---
    #     Avoid applying this script by accident to any host

    - name: Security --- exit if not booted from arch install media
      when: ansible_nodename != 'archiso'
      ansible.builtin.fail:
        msg: "This host is not booted from the Arch install media!"


    # --- Set variables ---
    #     Get system information required later in the process

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== SET VARIABLES =============================="

    - name: Check `efivars` directory existance
      ansible.builtin.stat:
        path: /sys/firmware/efi/efivars
      register: efivars
    - name: Get `firmware`
      ansible.builtin.set_fact:
        firmware: "{{ efivars.stat.exists | ternary('uefi', 'bios') }}"
    - name: Print `firmware`
      # https://wiki.archlinux.org/title/Arch_boot_process#Firmware_types
      ansible.builtin.debug:
        msg: "firmware = {{ firmware }}"

    - name: Get installation target `disk_name`
      # get `sda` or `nvme0n1` from `/dev/sda` or `/dev/nvme0n1`
      # see: https://wiki.archlinux.org/title/Device_file#Block_devices
      ansible.builtin.set_fact:
        disk_name: "{{ target_disk | split('/') | last }}"
    - name: Print `disk_name`
      ansible.builtin.debug:
        msg: "disk_name = {{ disk_name }}"

    - name: Get `disk_discard_support`
      # I don't have a PC with an nvme drive to test this now. For nvme disks this should be false because nvme has built in support for TRIM. Check this again whenever you have the oportunity.
      ansible.builtin.set_fact:
        disk_discard_support: "{{ ansible_devices[disk_name]['support_discard'] != '0' }}"
    - name: Print `disk_discard_support`
      ansible.builtin.debug:
        msg: "disk_discard_support = {{ disk_discard_support }}"

    - name: Determine partition names based on firmware type
      ansible.builtin.set_fact:
        efi_partition_number: "{{ (firmware == 'uefi') | ternary('1', None) }}"
        boot_partition_number: "{{ (firmware == 'uefi') | ternary('2', '1') }}"
        root_partition_number: "{{ (firmware == 'uefi') | ternary('3', '2') }}"
    - name: Prepend with "p" for disks names that end with a number
      # See `https://wiki.archlinux.org/title/Device_file#Partition`
      when: disk_name | regex_search('[0-9]$')
      ansible.builtin.set_fact:
        efi_partition_number: "p{{ efi_partition_number }}"
        boot_partition_number: "p{{ boot_partition_number }}"
        root_partition_number: "p{{ root_partition_number }}"
    - name: Print partition names
      ansible.builtin.debug:
        msg: "efi_partition_number = {{ efi_partition_number }}, boot_partition_number = {{ boot_partition_number }}, root_partition_number = {{ root_partition_number }}"


    # --- Disk configuration ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== DISK CONFIGURATION =============================="

    - name: Wipe all disk partitions of the target disk
      ansible.builtin.command: find /dev -wholename "{{ target_disk }}*" -exec wipefs --force --all {} \;

    - name: Securely erase disk (if instructed)
      when: secure_erase_disk
      block:
      - name: Info
        ansible.builtin.debug:
          msg: "About to write random data to the entire disk, will take several hours to complete"
      - name: Write random data to disk
        ansible.builtin.command: dd if=/dev/urandom of={{ target_disk }}

    - name: UEFI - Disk partitions
      when: firmware == 'uefi'
      block:
      - name: UEFI - Create EFI partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: gpt
          number: "{{ efi_partition_number }}"
          part_end: 512MB
          name: EFI
          flags: [boot, esp]
          fs_type: fat32
          state: present
      - name: UEFI - Create boot partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: gpt
          number: "{{ boot_partition_number }}"
          part_start: 512MB
          part_end: 1536MB
          name: boot
          fs_type: ext4
          state: present
      - name: UEFI - Create root partition
        community.general.parted:
          device: '{{ target_disk }}'
          label: gpt
          number: "{{ root_partition_number }}"
          part_start: 1536MB
          name: root
          flags: [lvm]
          state: present

    - name: BIOS - Disk partitions
      when: firmware == 'bios'
      block:
      - name: BIOS - Create boot partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: msdos
          number: "{{ boot_partition_number }}"
          part_end: 1024MB
          #name: boot
          fs_type: ext4
          flags: [boot]
          state: present
      - name: BIOS - Create root partition
        community.general.parted:
          device: "{{ target_disk }}"
          label: msdos
          number: "{{ root_partition_number }}"
          part_start: 1024MB
          #name: root
          flags: [lvm]
          state: present

    - name: Encrypt root partition
      community.crypto.luks_device:
        device: "{{ target_disk }}{{ root_partition_number }}"
        type: luks2
        new_passphrase: "{{ encryption_password }}"
        state: opened
        name: crypt
        passphrase: "{{ encryption_password }}"

    - name: LVM - Create volume group (physical volume is automatically created)
      community.general.lvg:
        pvs: /dev/mapper/crypt
        vg: vg0
        pvresize: true
        state: active

    - name: LVM - Create 'root' logical volume
      community.general.lvol:
        vg: vg0
        lv: root
        size: "{{ root_size_in_gb }}"
        active: true
    - name: LVM - Create 'home' logical volume
      community.general.lvol:
        vg: vg0
        lv: home
        size: +100%FREE
        active: true

    - name: UEFI - Format EFI partition
      when: firmware == 'uefi'
      community.general.filesystem:
        dev: "{{ target_disk }}{{ efi_partition_number }}"
        fstype: vfat
        opts: '-F32'
    - name: Format boot partition
      community.general.filesystem:
        dev: "{{ target_disk }}{{ boot_partition_number }}"
        fstype: ext4
    - name: Format `root` logical volume
      community.general.filesystem:
        dev: /dev/vg0/root
        fstype: ext4
    - name: Format `home` logical volume
      community.general.filesystem:
        dev: /dev/vg0/home
        fstype: ext4

    - name: Create directory for '/home'
      ansible.builtin.file:
        path: /mnt/home
        state: directory
    - name: Create directory for '/boot'
      ansible.builtin.file:
        path: /mnt/boot
        state: directory

    - name: Mount root
      ansible.posix.mount:
        src: /dev/vg0/root
        path: /mnt
        fstype: ext4
        state: mounted
    - name: Mount home
      ansible.posix.mount:
        src: /dev/vg0/home
        path: /mnt/home
        fstype: ext4
        state: mounted
    - name: Mount boot
      ansible.posix.mount:
        src: "{{ target_disk }}{{ boot_partition_number }}"
        path: /mnt/boot
        fstype: ext4
        state: mounted

    # --- Packages installation ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== PACKAGES INSTALLATION =============================="

    - name: Packages installation
      # `sudo` is required now because we will disable root login
      # check if you can ssh with the user account, otherwise install ssh in the second script
      ansible.builtin.command: pacstrap /mnt base linux linux-lts linux-firmware grub lvm2 sudo neovim networkmanager openssh ansible

    - name: Install `efibootmgr` (UEFI only)
      when: firmware == 'uefi'
      ansible.builtin.command: pacstrap /mnt efibootmgr


    # --- System configuration ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== SYSTEM CONFIGURATION =============================="

    - name: fstab - create '/etc' directory
      ansible.builtin.file:
        path: /mnt/etc
        state: directory
    - name: fstab - generate file
      ansible.builtin.shell:
        cmd: genfstab -U -p /mnt >> /mnt/etc/fstab
    - name: fstab - enable TRIM support (if supported)
      when: disk_discard_support
      ansible.builtin.replace:
        path: /mnt/etc/fstab
        regexp: '(relatime)\s+'
        replace: '\1,discard\t'

    - name: Setup hostname
      ansible.builtin.command: arch-chroot /mnt hostnamectl set-hostname "{{ inventory_hostname }}"
    # - name: Setup hostname
    #   ansible.builtin.copy:
    #     content: '{{ inventory_hostname }}'
    #     dest: /mnt/etc/hostname

    - name: Setup timezone
      ansible.builtin.command: arch-chroot /mnt ln -sf /usr/share/zoneinfo/{{ timezone }} /etc/localtime
    - name: Set hardware clock to current system time
      ansible.builtin.command: arch-chroot /mnt hwclock --systohc

    - name: Locales - enable locales desired locales
      lineinfile:
        dest: /mnt/etc/locale.gen
        regexp: '#{{ item }}\.UTF-8 UTF-8'
        line: '{{ item }}.UTF-8 UTF-8'
      loop: '{{ locales }}'
    - name: Locales - generate files
      ansible.builtin.command: arch-chroot /mnt locale-gen
    - name: Locales - setup locale language
      ansible.builtin.copy:
        content: LANG={{ locales | first }}.UTF-8
        dest: /mnt/etc/locale.conf
    - name: Locales - setup console keymap
      ansible.builtin.command: arch-chroot /mnt echo KEYMAP={{ console_keymap }} > /etc/vconsole.conf

    - name: Enable `NetworkManager` service
      # required to be able to connect to a wireless network later
      ansible.builtin.command: arch-chroot /mnt systemctl enable NetworkManager

    - name: Enable `sshd` service
      # check if you can login with the useraccount, otherwise do this later
      ansible.builtin.command: arch-chroot /mnt systemctl enable sshd NetworkManager


    # --- Initial ram filesystem ---
    #     The initramfs is a temporary filesystem that is loaded into memory during
    #     the boot process before the real root filesystem is mounted. We need to 
    #     recreate the initramfs with support for LVM and disk encryption.

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== INITRAMFS =============================="

    - name: initramfs - create a key file to avoid typing the encryption password twice during boot
      block:
      - name: initramfs - create an empty file
        ansible.builtin.shell: arch-chroot /mnt dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin
      - name: initramfs - append the encryption key to it
        ansible.builtin.shell: echo "{{ encryption_password }}" | arch-chroot /mnt  cryptsetup luksAddKey {{ target_disk }}{{ root_partition_number }} /crypto_keyfile.bin -
      - name: initramfs - remove all permissions for security reasons
        ansible.builtin.command: arch-chroot /mnt chmod 000 /crypto_keyfile.bin

    - name: initramfs - change configuration options for the `mkinitcpio` script
      # mkinitcpio is a Bash script used to create an initial ramdisk environment
      lineinfile:
        dest: /mnt/etc/mkinitcpio.conf
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # add the key file
        - { regex: ^FILES, line: FILES=(/crypto_keyfile.bin) }
        # add teh `encrypt` and `lvm2` hooks
        - { regex: ^HOOKS, line: HOOKS=(base udev autodetect modconf kms keyboard keymap consolefont block encrypt lvm2 filesystems fsck) }

    - name: initramfs - Generate the initial ramdisk image for `linux`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -p linux
    - name: initramfs - Generate the initial ramdisk image for `linux-lts`
      ansible.builtin.command: arch-chroot /mnt mkinitcpio -p linux-lts


    # --- Bootloader ---
    #     https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== BOOTLOADER =============================="

    - name: Bootloader (UEFI) - create '/boot/EFI' directory
      when: firmware == 'uefi'
      ansible.builtin.file:
        path: /mnt/boot/EFI
        state: directory
    - name: Bootloader (UEFI) - mount EFI partition
      when: firmware == 'uefi'
      ansible.posix.mount:
        src: "{{ target_disk }}{{ efi_partition_number }}"
        path: /mnt/boot/EFI
        fstype: vfat
        state: mounted

    - name: Bootloader (UEFI) - install grub
      when: firmware == 'uefi'
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=x86_64-efi --recheck {{ target_disk }}"
    - name: Bootloader (BIOS) - install grub
      when: firmware == 'bios'
      ansible.builtin.command: "arch-chroot /mnt grub-install --target=i386-pc --recheck {{ target_disk }}"

    - name: Bootloader - Configure GRUB
      lineinfile:
        dest: /mnt/etc/default/grub
        regexp: '{{ item.regex }}'
        line: '{{ item.line }}'
      loop:
        # enable encryption
        - { regex: ^#GRUB_ENABLE_CRYPTODISK, line: GRUB_ENABLE_CRYPTODISK=y }
        # enable TRIM (if supported) and encryption
        - { regex: ^GRUB_CMDLINE_LINUX="", line: "GRUB_CMDLINE_LINUX=\"{{ disk_discard_support | ternary('cryptdevice={{ target_disk }}{{ root_partition_number }}:crypt:allow-discards', 'cryptdevice={{ target_disk }}{{ root_partition_number }}:crypt') }}\"" }

    - name: Bootloader - generate boot loader file
      ansible.builtin.command: "arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg"


    # --- Enable swap ---

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== ENABLE SWAP =============================="

    - name: Enable swap
      when: swap_size_in_mb > 0
      block:
      - name: Swap - Create empty file of desired size
        ansible.builtin.command: arch-chroot /mnt dd if=/dev/zero of=/swapfile bs=1M count={{ swap_size_in_mb }} status=progress
      - name: Swap - Change file permissions
        ansible.builtin.command: arch-chroot /mnt chmod 600 /swapfile
      - name: Swap - Set file as swap file
        ansible.builtin.command: arch-chroot /mnt mkswap /swapfile
      - name: Swap - Include swap file in `/etc/fstab`
        lineinfile:
          path: /mnt/etc/fstab
          line: "/swapfile none swap sw 0 0"
      - name: Swap - Check fstab file correctness
        ansible.builtin.command: arch-chroot /mnt mount -a
      - name: Swap - Enable
        ansible.builtin.command: arch-chroot /mnt swapon -a


    # --- User accounts ---
    #     the root user is disabled by default
    #     the user account will have super user privileges

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== USER ACCOUNTS =============================="

    - name: User account - create group
      ansible.builtin.group:
        name: "{{ username }}"
    - name: User account - generate password hash
      # Archlinux changed the password hashing algorithm from `sha512` to `yescript` (https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/)
      # openssl does not support `yescript` yet, when it does update the `-6` flag to the one corresponding to `yescript`
      ansible.builtin.command: "openssl passwd -6 {{ password }}"
      register: password_hash
    - name: User account - create account
      ansible.builtin.user:
        name: "{{ username }}"
        # primary group
        group: "{{ username }}"
        # supplementary groups --- https://wiki.archlinux.org/title/Users_and_groups#Group_list
        #   `wheel` is used by polkit for administrative tasks
        #   `input` and `uinput` are required for `kmonad`
        groups: adm,wheel,input,uinput
        # password hashed are stored in `/etc/shadow`
        password: "{{ password_hash.stdout }}"
        # the shell must be one of those listed in `/etc/shells`, zsh is not available yet
        shell: /bin/bash
    - name: User account - create sudoers file
      ansible.builtin.copy:
        # https://wiki.archlinux.org/title/Sudo#Configure_sudo_using_drop-in_files_in_/etc/sudoers.d
        content: "{{ username }} ALL=(ALL:ALL) NOPASSWD: ALL"
        dest: "/etc/sudoers.d/{{ username }}"
        owner: root
        group: root
        # https://wiki.archlinux.org/title/Sudo#Sudoers_default_file_permissions
        mode: 0440
    - name: User account - create the `.vault_key` file in the users home directory
      # This will allow us to run the second script without manually creating this file
      ansible.builtin.copy:
        content: "{{ encryption_password }}"
        dest: "/home/{{ username }}/.vault_key"
        owner: root
        group: root
        # https://wiki.archlinux.org/title/Sudo#Sudoers_default_file_permissions
        mode: 0440

    - name: Disable root login
      # Reduce the surface for attacks
      # https://wiki.archlinux.org/title/Sudo#Disable_root_login
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/user_module.html#parameter-password
      ansible.builtin.user:
        name: root
        password: '!'
    # - name: root account - Generate password hash
    #   (In case you ever want to create a password for the root account, you must edit the shadow file manually)
    #   # arch changes the password hashing algorithm from `sha512` to `yescript` (https://archlinux.org/news/changes-to-default-password-hashing-algorithm-and-umask-settings/)
    #   # openssl does not support `yescript` yet, when it does update the `-6` flag to the one corresponding to `yescript`
    #   ansible.builtin.command: openssl passwd -6 "{{ encryption_password }}"
    #   register: passwd_hash
    # - name: root acount - Manually add the hashed password to `/etc/shadow`
    #   ansible.builtin.replace:
    #     path: /mnt/etc/shadow
    #     regexp: (^root):([^:]*):(.*)
    #     replace: \1:{{ passwd_hash.stdout }}:\3

    # --- Reboot and exit playbook

    - name: Notify section
      ansible.builtin.debug:
        msg: "============================== RESTARTING =============================="
      
    - name: Shutdown
      community.general.shutdown:

    - name: Exit playbook gracefully
      ansible.builtin.meta: end_host

